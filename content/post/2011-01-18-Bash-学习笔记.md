---
title: "Bash 学习笔记"
author: "axiaoxin"
date: 2011-01-18T17:25:50+08:00
subtitle: ""
image: ""
tags: ["linux"]
slug: ""
---

## Bash 的工作控制

`%%` 或 `%+` 可调用 jobs 里面现在的工作，`%-` 调用前一个工作

`%n` 将工作编号为 n 的进程置于前台来执行 == `fg %n`

`%?s1` 调用程序名称中含有s1的工作，? 表示搜寻

`%./s1` 找出进程名开头是 ./s1 的工作

`C-z` 暂停进程，然后 bg 丢到后台 == 指令 `&`

`disown %n`：移除工作


## Bash 的历史指令

`!-n` ：执行倒数第n个命令

`!!` ：执行前一个你是指令

`!` 字符串：执行最近一个含有以‘字符串’开头的历史命令

`!?字符串?` ：执行最近一个含有‘字符串’的历史指令

`!#` ：目前所键入的字符串

`!!:$` ：取得前一个命令的最后一个参数

`!ls:1` ：找出最近一个以ls开头的指令的第一个参数，^第一个，*所有参数，

`!!:3-5` ：找出前一个指令中，介于字符串3到5的参数

`!!:s/字符串1/字符串2/` ：将前一个指令中的字符串1替换为字符串2

`!!:h` ：删除后面的文件名

`!!:t` ：删除前面的目录

`!!:p` ：显示前面的指令，但不执行。

## Bash 数组用法

定义数组：`a=(1 2 3 4 5)` , `a=(1 [4]=4 5 )` 可以不连续，不连续的地方为空。

获取值：`${a[index]}`

获取所有元素：`${a[@]}` 返回数字`1 2 3 4 5`，`${a[*]}`返回`"1 2 3 4 5"`

获取元素个数：`${#a[@]}`, `${#a[*]}`

## 调整 Bash 变量的属性为 readonly

`readonly 变量名`

`readonly、readonly -p`  ：显示只读属性的变量列表

`readonly -f 函数名`

`readonly -a 数组名`：`readonly -a s; s[3]=10`

`declare -r 变量名`

**declare用法** ：

- `-p` 显示变量属性
- `-a` 变量是数组
- `-f` 搜寻命令只找函数
- `-i` 变量是一个整数
- `-F` 显示所有函数式名称及其属性
- `-r` 设定只读变量
- `-t` 设立变量具有trace属性
- `-x` 设为环境变量

## Bash 高级变量用法

**变量**

- `${变量名}`
- `$(命令)`
- `${待测变量:-替换值}` ：判断变量是否不存在或者为空（冒号），成立则返回替换值
- `${待测变量:=替换值}` ：判断变量是否不存在或者为空（冒号），成立则赋值为替换值
- `${待测变量:?错误信息}` ：判断变量是否不存在或者为空（冒号），成立则赋值为替换值
- `${待测变量:+替换值}` ：判断变量是否存在或者非空（冒号），成立则返回替换值

**切片**

- `${变量:位置起始点}`
- `${变量:位置起始点:长度}`

**取部分位置参数**

- `${@:1}`

**计算字符串长度**

- `${#str}`
- `expr length "字符串"`

**对比样式，删除相符的**

- `${变量#样式}`：由前面开始，最短删除
- `${变量##样式}`：由前面开始，最长删除
- `${变量%样式}`：由后面开始，最短删除
- `${变量%%样式}`：由后面开始，最长删除

**取代或删除部分字符串**

- 只替换第一个符合的：`${变量/样式/替换字符串}`
- 替换全部符合的：`${变量//样式/替换字符串}`
- 只匹配行首：`${变量/#样式/替换字符串}`
- 只匹配行末：`${变量/%样式/替换字符串}`
- 删除：`不加替换字符串表示删除`

**列出指定字符串开头的变量名列表**

`${!开头字符串@}`, `${!开头字符串*}`

**数组索引列表**

`${!数组变量[@]}`, `${!数组变量[*]}`

**算术拓展**

- `$((算术式))`
- `expr 算术式`
- `$[算术式]`
- `declare -i 变量=算术式`
- `let 算术式`

算术式中如果值不存在或者为空，则默认为0

不同进制的数字可使用“`基底#数字`”表示

`let` 表达式加空格必须为表达式加引号

```shell
let "i = i + 5"
```
**查找文件中的关键字**：

```shell
grep -q "keyword" filename
```

**返回命令结果的相反值**：

`! 空格 命令`

`[  判断式  ] && 指令1 || 指令2  等价于  A?B:C`

在 `[[  ]]` 和 `(())` 中表达式不用转义符

**高级样式**

- `@(样式串行)` ：如果符合括号里样式串行的其中一个就算对比符合
- `!(样式串行)` ：只要不出现在括号中就算对比符合

eg：

```shell
    read name
    case $name in
          j@(ay|oin|uly|oe) echo "good";;
          *) echo "nice";;
    esac
```

