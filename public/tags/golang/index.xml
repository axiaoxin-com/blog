<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on 阿小信的博客</title>
    <link>https://blog.axiaoxin.com/tags/golang/</link>
    <description>Recent content in golang on 阿小信的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cmn-Hans</language>
    <managingEditor>admin@axiaoxin.com (axiaoxin)</managingEditor>
    <webMaster>admin@axiaoxin.com (axiaoxin)</webMaster>
    <lastBuildDate>Sat, 26 Nov 2022 22:04:06 +0800</lastBuildDate><atom:link href="https://blog.axiaoxin.com/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang 使用 Redis ZSET 实现排行榜</title>
      <link>https://blog.axiaoxin.com/post/2022-11-26-golang-%E4%BD%BF%E7%94%A8-redis-zset-%E5%AE%9E%E7%8E%B0%E6%8E%92%E8%A1%8C%E6%A6%9C/</link>
      <pubDate>Sat, 26 Nov 2022 22:04:06 +0800</pubDate>
      <author>admin@axiaoxin.com (axiaoxin)</author>
      <guid>https://blog.axiaoxin.com/post/2022-11-26-golang-%E4%BD%BF%E7%94%A8-redis-zset-%E5%AE%9E%E7%8E%B0%E6%8E%92%E8%A1%8C%E6%A6%9C/</guid>
      <description>本文介绍如何使用 Golang 采用 Redis 的有序集合 zset 实现一个用户排行榜。 用户排行榜按用户的某一种排序值进行排序，比如充值金额，当该排序值相同时，则需按达成该</description>
    </item>
    
    <item>
      <title>Gin 使用 GNU gettext 方式实现 i18n 国际化多语言</title>
      <link>https://blog.axiaoxin.com/post/2022-06-23-gin-%E4%BD%BF%E7%94%A8-gnu-gettext-%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0-i18n-%E5%9B%BD%E9%99%85%E5%8C%96%E5%A4%9A%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Thu, 23 Jun 2022 10:50:19 +0800</pubDate>
      <author>admin@axiaoxin.com (axiaoxin)</author>
      <guid>https://blog.axiaoxin.com/post/2022-06-23-gin-%E4%BD%BF%E7%94%A8-gnu-gettext-%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0-i18n-%E5%9B%BD%E9%99%85%E5%8C%96%E5%A4%9A%E8%AF%AD%E8%A8%80/</guid>
      <description>i18n 国际化多语言本质上就是先写好一堆映射，在根据想要的语言取对应的文字。 Golang 的 i18n 多语言方案网上查了一下，文章都讲的不太细致，而且代码看起来也不太</description>
    </item>
    
    <item>
      <title>Golang JSON 序列化时 HTML 特殊字符转义问题分析</title>
      <link>https://blog.axiaoxin.com/post/2021-11-21-golang-json-%E5%BA%8F%E5%88%97%E5%8C%96%E6%97%B6-html-%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E8%BD%AC%E4%B9%89%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 21 Nov 2021 20:19:45 +0800</pubDate>
      <author>admin@axiaoxin.com (axiaoxin)</author>
      <guid>https://blog.axiaoxin.com/post/2021-11-21-golang-json-%E5%BA%8F%E5%88%97%E5%8C%96%E6%97%B6-html-%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E8%BD%AC%E4%B9%89%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</guid>
      <description>场景复现 在 API 实现中返回一个 JSON 结果，其中有一个字段为 URL 链接，客户端拿到该链接后做请求，URL 链接中存在多个使用 &amp;amp; 连接的 querystring 参数。 服务端实现时，通</description>
    </item>
    
    <item>
      <title>Golang 运行时除数为 0 返回 Inf</title>
      <link>https://blog.axiaoxin.com/post/2021-11-21-golang-%E8%BF%90%E8%A1%8C%E6%97%B6%E9%99%A4%E6%95%B0%E4%B8%BA-0-%E8%BF%94%E5%9B%9E-inf/</link>
      <pubDate>Sun, 21 Nov 2021 18:23:31 +0800</pubDate>
      <author>admin@axiaoxin.com (axiaoxin)</author>
      <guid>https://blog.axiaoxin.com/post/2021-11-21-golang-%E8%BF%90%E8%A1%8C%E6%97%B6%E9%99%A4%E6%95%B0%E4%B8%BA-0-%E8%BF%94%E5%9B%9E-inf/</guid>
      <description>在 Golang 中，除数为 0 时，常规情况下是无法编译通过的，但是如果除数是由运行时决定的，那么为除数为 0 时则不会 panic，而是实现为 IEEE 754 标准，返回 In</description>
    </item>
    
    <item>
      <title>Traefik 简介以及中间件插件开发</title>
      <link>https://blog.axiaoxin.com/post/2021-10-11-traefik-%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</link>
      <pubDate>Mon, 11 Oct 2021 17:22:19 +0800</pubDate>
      <author>admin@axiaoxin.com (axiaoxin)</author>
      <guid>https://blog.axiaoxin.com/post/2021-10-11-traefik-%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</guid>
      <description>Traefix 简介 Traefik 是整个系统的网关大门，负责拦截并路由每个传入的请求，它不需要像Nginx这类反向代理一样需要一个配置文件来配置所有可能路由，而是实时</description>
    </item>
    
    <item>
      <title>使用 Github Actions 自动部署 Golang 应用到 VPS 服务器</title>
      <link>https://blog.axiaoxin.com/post/2021-06-19-%E4%BD%BF%E7%94%A8-github-actions-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-golang-%E5%BA%94%E7%94%A8%E5%88%B0-vps-%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Sat, 19 Jun 2021 16:12:08 +0800</pubDate>
      <author>admin@axiaoxin.com (axiaoxin)</author>
      <guid>https://blog.axiaoxin.com/post/2021-06-19-%E4%BD%BF%E7%94%A8-github-actions-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-golang-%E5%BA%94%E7%94%A8%E5%88%B0-vps-%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>环境说明 使用 GitHub Actions 可以在你提交代码后自动将最新代码编译发布部署到你的 VPS 服务器，这里记录一下配置步骤。 服务没有使用 Docker 部署，直接通过 supervisord 启动二进制文</description>
    </item>
    
    <item>
      <title>实现自定义的 Gin Logger 中间件</title>
      <link>https://blog.axiaoxin.com/post/2021-05-13-gin-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%E4%B8%AD%E9%97%B4%E4%BB%B6/</link>
      <pubDate>Thu, 13 May 2021 15:49:52 +0800</pubDate>
      <author>admin@axiaoxin.com (axiaoxin)</author>
      <guid>https://blog.axiaoxin.com/post/2021-05-13-gin-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%E4%B8%AD%E9%97%B4%E4%BB%B6/</guid>
      <description>gin 的中间件原理解析 在 gin 中，中间件是一系列 gin.HandlerFunc 链，它的函数签名类型和我们业务中写的URL对应的 handler 是一样的，都是gin.HandlerFunc。 gin</description>
    </item>
    
    <item>
      <title>Golang 并发 append slice 时的并发安全问题分析与总结</title>
      <link>https://blog.axiaoxin.com/post/2021-05-13-golang-%E5%B9%B6%E5%8F%91-append-slice-%E6%97%B6%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 13 May 2021 00:00:00 +0000</pubDate>
      <author>admin@axiaoxin.com (axiaoxin)</author>
      <guid>https://blog.axiaoxin.com/post/2021-05-13-golang-%E5%B9%B6%E5%8F%91-append-slice-%E6%97%B6%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/</guid>
      <description>背景 导出数据库中的数据，由于数据量巨大且查询复杂，完成导出的时间很长，因此通过将并发查询然后将结果合并到一起。 在导出的数据量只有30多万时，</description>
    </item>
    
    <item>
      <title>Go 单元测试 gostub 打桩使用方法</title>
      <link>https://blog.axiaoxin.com/post/2020-06-02-go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-gostub-%E6%89%93%E6%A1%A9%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 02 Jun 2020 15:10:33 +0800</pubDate>
      <author>admin@axiaoxin.com (axiaoxin)</author>
      <guid>https://blog.axiaoxin.com/post/2020-06-02-go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-gostub-%E6%89%93%E6%A1%A9%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description>golang 单元测试中常用以下 4 个库方便测试代码的编写： gostub 主要用来给变量、函数、过程打桩 但是给函数打桩时，需要做侵入式修改 convey 主要用途是用来组织测试用例</description>
    </item>
    
    <item>
      <title>在 Zap 中集成 Sentry 自动上报 Error 事件</title>
      <link>https://blog.axiaoxin.com/post/2020-03-15-%E5%9C%A8-zap-%E4%B8%AD%E9%9B%86%E6%88%90-sentry-%E8%87%AA%E5%8A%A8%E4%B8%8A%E6%8A%A5-error-%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Sun, 15 Mar 2020 10:03:10 +0800</pubDate>
      <author>admin@axiaoxin.com (axiaoxin)</author>
      <guid>https://blog.axiaoxin.com/post/2020-03-15-%E5%9C%A8-zap-%E4%B8%AD%E9%9B%86%E6%88%90-sentry-%E8%87%AA%E5%8A%A8%E4%B8%8A%E6%8A%A5-error-%E4%BA%8B%E4%BB%B6/</guid>
      <description>在项目中发生了错误时我们都会打印 Error 级别的日志，但是即使有日志采集，在对发生 Error 时的告警通知和信息采集都不一定能快速且完善，目前对日志的告警也只</description>
    </item>
    
    <item>
      <title>Zap 源码阅读笔记</title>
      <link>https://blog.axiaoxin.com/post/2020-01-16-zap-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 16 Jan 2020 18:56:42 +0800</pubDate>
      <author>admin@axiaoxin.com (axiaoxin)</author>
      <guid>https://blog.axiaoxin.com/post/2020-01-16-zap-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</guid>
      <description>zap.Logger 日志Logger结构体，以此调用打印日志内容，定义如下： type Logger struct { core zapcore.Core development bool name string errorOutput zapcore.WriteSyncer addCaller bool addStack zapcore.LevelEnabler callerSkip int } zapcore.Entry 日志主体内容结构体，表示一条具体日志，定义</description>
    </item>
    
    <item>
      <title>我和 Dave 有个约会</title>
      <link>https://blog.axiaoxin.com/post/2019-04-29-%E6%88%91%E5%92%8C-dave-%E6%9C%89%E4%B8%AA%E7%BA%A6%E4%BC%9A/</link>
      <pubDate>Mon, 29 Apr 2019 17:50:57 +0800</pubDate>
      <author>admin@axiaoxin.com (axiaoxin)</author>
      <guid>https://blog.axiaoxin.com/post/2019-04-29-%E6%88%91%E5%92%8C-dave-%E6%9C%89%E4%B8%AA%E7%BA%A6%E4%BC%9A/</guid>
      <description>Start 今天上午参加了 Go 语言项目开发成员 Dave Cheney 的分享。 分享的主题是《High Performance Go: Two tools, three types of profiling in 45 minutes》 分享的内容来自 https://dave.cheney.net/high-performance-go-workshop/gopherchina-2019.html 非常有干货的分享！ 两</description>
    </item>
    
    <item>
      <title>Go 中通过组织结构体以节省内存</title>
      <link>https://blog.axiaoxin.com/post/2018-12-11-go-%E4%B8%AD%E9%80%9A%E8%BF%87%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E4%BD%93%E4%BB%A5%E8%8A%82%E7%9C%81%E5%86%85%E5%AD%98/</link>
      <pubDate>Tue, 11 Dec 2018 17:35:07 +0800</pubDate>
      <author>admin@axiaoxin.com (axiaoxin)</author>
      <guid>https://blog.axiaoxin.com/post/2018-12-11-go-%E4%B8%AD%E9%80%9A%E8%BF%87%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E4%BD%93%E4%BB%A5%E8%8A%82%E7%9C%81%E5%86%85%E5%AD%98/</guid>
      <description>先执行一段示例代码，有一个类似如下的结构体 myStruct： package main import ( &amp;#34;fmt&amp;#34; &amp;#34;reflect&amp;#34; &amp;#34;unsafe&amp;#34; ) type myStruct struct { myBool bool myFloat float64 myInt int32 } func main() { a := myStruct{} fmt.Println(unsafe.Sizeof(a.myBool)) // 1 fmt.Println(unsafe.Sizeof(a.myFloat)) // 8 fmt.Println(unsafe.Sizeof(a.myInt)) // 4 fmt.Println(unsafe.Sizeof(a)) // 24 fmt.Println(reflect.TypeOf(a.myBool).Align()) // 1</description>
    </item>
    
    <item>
      <title>自定义 Golang Time 类型字段的 JSON 序列化格式</title>
      <link>https://blog.axiaoxin.com/post/2018-11-05-%E8%87%AA%E5%AE%9A%E4%B9%89-golang-time-%E7%B1%BB%E5%9E%8B%E5%AD%97%E6%AE%B5%E7%9A%84-json-%E5%BA%8F%E5%88%97%E5%8C%96%E6%A0%BC%E5%BC%8F/</link>
      <pubDate>Mon, 05 Nov 2018 19:18:32 +0800</pubDate>
      <author>admin@axiaoxin.com (axiaoxin)</author>
      <guid>https://blog.axiaoxin.com/post/2018-11-05-%E8%87%AA%E5%AE%9A%E4%B9%89-golang-time-%E7%B1%BB%E5%9E%8B%E5%AD%97%E6%AE%B5%E7%9A%84-json-%E5%BA%8F%E5%88%97%E5%8C%96%E6%A0%BC%E5%BC%8F/</guid>
      <description>Golang 中自定义 time.Time 类型的 JSON 序列化格式 Golang 中时间格式定义： const ( ANSIC = &amp;#34;Mon Jan _2 15:04:05 2006&amp;#34; UnixDate = &amp;#34;Mon Jan _2 15:04:05 MST 2006&amp;#34; RubyDate = &amp;#34;Mon Jan 02 15:04:05 -0700 2006&amp;#34; RFC822 = &amp;#34;02 Jan 06 15:04 MST&amp;#34; RFC822Z = &amp;#34;02 Jan 06 15:04 -0700&amp;#34; // RFC822 with numeric zone RFC850 =</description>
    </item>
    
    <item>
      <title>Golang WEB 框架选型</title>
      <link>https://blog.axiaoxin.com/post/2018-10-17-golang-web-%E6%A1%86%E6%9E%B6%E9%80%89%E5%9E%8B/</link>
      <pubDate>Wed, 17 Oct 2018 17:22:52 +0800</pubDate>
      <author>admin@axiaoxin.com (axiaoxin)</author>
      <guid>https://blog.axiaoxin.com/post/2018-10-17-golang-web-%E6%A1%86%E6%9E%B6%E9%80%89%E5%9E%8B/</guid>
      <description>Go 本身默认就已经具备了 WEB 开发的特性，net/http 包 + httprouter 开发一个 apiserver 已经足够了， 写好包含 http.ResponseWriter 和 *http.Request 参数的业务处理函数，通过 http.HandleFunc 注册路由就可以了。 近</description>
    </item>
    
    <item>
      <title>使用 Go 定义一个可以调用任意函数的函数</title>
      <link>https://blog.axiaoxin.com/post/2018-10-15-%E4%BD%BF%E7%94%A8-go-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E4%BB%BB%E6%84%8F%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 15 Oct 2018 17:07:44 +0800</pubDate>
      <author>admin@axiaoxin.com (axiaoxin)</author>
      <guid>https://blog.axiaoxin.com/post/2018-10-15-%E4%BD%BF%E7%94%A8-go-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E4%BB%BB%E6%84%8F%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0/</guid>
      <description>原始需求是这样的：我需要监听一个json文件是否发生变化，一旦发生变化就重新调用函数读取文件中新的json来更新一个变量。 现在的需求是想把这</description>
    </item>
    
  </channel>
</rss>
